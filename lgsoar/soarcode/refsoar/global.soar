
# File: global.soar
# Author: William Taysom
# Version 2.0: July 24, 2001
# Created: July 6, 2001
#
# Operators:	start-next-sentence (0), generate-predicates (0), find-root (205),
#				return-to-nil
# Preference:	prefer*operator-with-highest-priority, prefer*operator-with-lowest-order
# Other:		terminate*operator, halt
#
# TO DO:
#

## start-next-sentence

# SBW 3/19/2012
# - changed to act with a single snc, not two levels (that doesn't happen with
# the wait operator)
# - changed to only propose when another, unhandled, sentence exists
# - split to another operator, wrap-up, for when another sentence doesn't exist
sp {global*propose*start-next-sentence
   (state <s> ^impasse no-change ^superstate <ss>)
   (<ss> ^problem-space lgsoar ^io.lgsentence.count { <next-count> > <count> } ^count <count>)
-->
   (<ss> ^operator <o> + >)
   (<o> ^name start-next-sentence ^priority -1 ^count <count>)
}

sp	{global*apply*start-next-sentence
   (state <s> ^operator <o> ^refsets <refsets> ^root <root> ^anaphor <a>)
   (<o> ^name start-next-sentence ^count <count> )
-->
   (<a> ^unblock? no - general +)
   (<s> ^root <root> - 0 +)
   (<s> ^count <count> - (+ 1 <count>))
   (<refsets> ^refs <refs> +)
   (<refs> ^count (+ 1 <count>))
}

sp {global*propose*generate-predicates
   (state <s> ^impasse no-change ^attribute state ^superstate <ss>)
   (<ss> ^problem-space lgsoar 
        -^predicates-generated 
         ^anaphor.unblock? no
         ^problem-space lgsoar
         -^io.lgsentence.count { <next-count> > <count> } ^count <count>)
-->
   (<ss> ^operator <o> + >)
   (<o> ^name generate-predicates ^priority -1)
}

# don't choke completely if some preds can't be generated
sp {global*elaborate*generate-predicates*failed
   (state <s> ^impasse no-change ^attribute operator ^superstate <ss>)
   (<ss> ^operator.name generate-predicates
         ^model.idea <id>)
   (<id> ^nuc <nuc>
        -^annotation pred-dumped)
-->
   (write (crlf) |WARNING: generate-predicates failed to find a predicate representation for idea | <id> |, nucleus | <nuc>)
  (<id> ^annotation pred-dumped)
}

sp {global*propose*find-root
	(state <s> ^count <count> ^io.lgsentence <cs> ^root <old>)
	(<cs> ^count <count> ^links.link <link> ^words.word <child> <parent>)
	(<child> ^wcount <old> ^wvalue <oldVal>)
	(<parent> ^wcount <new> ^wvalue <newVal>)
	(<link> ^lwleft <old> ^lwright <new>)
	(<link> ^ltype {<< AN D A AA AF AM AN BW D DD DG DP DT E EA EC EE EI EN EZ G GN H I MF
					  NR NS NT NW S SX TD TH TI TM TO W WR Y YP YS  >> <type>})
-->
	(<s> ^operator <o> + >)
	(<o> ^name find-root ^priority 170 ^new <new> 
       ^debug-info (concat |finding root verb: traversed | <type> | link from "| <oldVal> |" to "| <newVal> |"|))
}

sp	{global*apply*find-root
   (state <s> ^operator <o> ^root <old>)
   (<o> ^name find-root ^new <new>)
-->
   (<s> ^root <old> - <new> +)}


## return-to-nil

sp	{global*propose*return-to-nil
   (state <s> ^superstate <ss>
             -^impasse tie)
   (<ss> ^count <count> ^refsets.refs <refs>)
   (<refs> ^count <count> ^ref <ref>)
   (<ref> ^return-to-nil ^head.wcount <wcount>)
-->
   (<ss> ^operator <o> +)
   (<o> ^name return-to-nil ^order <wcount> ^ref <ref> )
}

sp	{global*apply*return-to-nil*if-refs-not-marked-complete
   (state <s> ^operator <o> ^io.lgsentence.words.word <word> ^count <count> ^refsets.refs <refs>)
   (<refs> ^count <count>)# -^complete?)
   (<o> ^name return-to-nil ^ref <ref> )
   (<ref> ^return-to-nil <rcount> ^head <head>)
   (<head> ^wcount <wcount>)
   (<word> ^return <wcount>)
-->
   (<head> ^wcount <wcount> - <rcount> +)
   (<word> ^return <wcount> -)
   (<word> ^wcount <wcount>)
   (<ref> ^return-to-nil <rcount> -)
   (<ref> ^special empty +)
}

# sp	{global*apply*return-to-nil*if-refs-marked-complete
#    (state <s> ^operator <o> ^io.lgsentence.words.word <word> ^count <count> ^refsets.refs <refs>)
#    (<refs> ^count <count> ^complete?)
#    (<o> ^name return-to-nil ^ref <ref> )
#    (<ref> ^return-to-nil <rcount> ^head <head>)
#    (<head> ^wcount <wcount>)
#    (<word> ^return <wcount>)
# -->
#    (<head> ^wcount <wcount> - <rcount> +)
#    (<word> ^return <wcount> -)
#    (<word> ^wcount <wcount>)
#    (<ref> ^return-to-nil <rcount> -)
#    (<ref> ^special empty +)
# }


## Preference Rules
# Prefer operator with highest priority

sp	{global*prefer*operator-with-highest-priority
   (state <s> ^operator <deferred> + <preferred> +)
   (<deferred> ^priority <def-priority>)
   (<preferred> ^priority <pref-priority> > <def-priority>)
-->
   (<s> ^operator <preferred> > <deferred>)}

# Prefer operator with lowest linear order if priority is equal

sp	{global*prefer*operator-with-lowest-order*if-priority-is-equal
   (state <s> ^operator <deferred> + <preferred> +)
   (<deferred> ^priority <priority> ^order <last>)
   (<preferred> ^priority <priority> ^order <first> < <last>)
-->
   (<s> ^operator <preferred> > <deferred>)}

# Prefer operator with lowest lexical (level 2) order if (level 1) order is equal

sp	{global*prefer*operator-with-lowest-order*if-order-is-equal
   (state <s> ^operator <deferred> + <preferred> +)
   (<deferred> ^priority <priority> ^order <order> ^level-two-order <last>)
   (<preferred> ^priority <priority> ^order <order> ^level-two-order <first> < <last>)
-->
   (<s> ^operator <preferred> > <deferred>)}

# SBW added some indifferent rules to handle identical priorities
# these cases probably represent bugs!

sp {global*apply*generate-predicates*note-any-annotation-anywhere
   (state <s> ^count <count> ^operator.name generate-predicates ^model <mod>)
   (<mod> ^idea <idea>)
   (<idea> ^annotation <any>)
-->
   (<mod> ^did-idea-annotation yes +)
}

sp {global*apply*generate-predicates*generated
  (state <s> ^operator.name generate-predicates)
   -{(<s> ^model.idea <id>)
     (<id> -^annotation pred-dumped)}
-->
  (<s> ^predicates-generated true)
}

sp {global*propose*processing-complete
   (state <s> ^problem-space lgsoar
              ^predicates-generated true)
-->
   (<s> ^operator <o> +)
   (<o> ^name processing-complete
        ^priority 900)
}

# most LGSoar state is removed since it is below structures elaborated
# from activate*create*space, which retracts when the sentence is flagged done

# clean up any remaining state here
sp {global*apply*processing-complete*cleanup
   (state <s> ^operator.name processing-complete
              ^root <rt>
              ^count <ct>)
-->
   (<s> ^root <rt> -
        ^count <ct> -)
}

# excise this and add something project-specific
sp {global*apply*processing-complete
   (state <s> ^operator.name processing-complete)
-->
   (halt)
}

sp {lg*resolve-ties-indifferently
   (state <s> ^impasse tie
              ^item-count < 10 # don't explode with matches
              ^attribute operator
              ^item <o1>
              ^item <o2>
              ^superstate <ss>)
   (<ss> ^problem-space lgsoar
        ^operator <o1> +
        ^operator <o2> +)
-->
  (<ss> ^operator <o1> = <o2>)
   (write (crlf) |WARNING: LGSoar tie encountered, resolving indifferently in order to make progress.|)
}

# handle idioms..

# need a simple workaround so the sentence can be edited in place
# (it is made of read-only input WMEs)
# Java code changed to make original-wvalue rather than wvalue
sp {global*elaborated*wvalue
   (state <s> ^problem-space lgsoar
              ^io.lgsentence.words.word <wd>)
   (<wd> ^original-wvalue <wv>)
-->
   (<wd> ^wvalue <wv>)
}

sp {global*elaborate*unexpanded-idiom
   (state <s> ^problem-space lgsoar
              ^io.lgsentence <sent>)
   (<sent> ^links.link <ln>
           ^words.word <rightword>)
   (<rightword> ^wcount <rightc>)
   (<ln> ^ltype ID
         ^lwright <rightc>)
-->
   (<rightword> ^unexpanded-idiom true)
}

sp {global*propose*expand-idiom
   (state <s> ^problem-space lgsoar
              ^count <ct>
              ^io.lgsentence <sent>)
   (<sent> ^count <ct>
           ^words.word <wd>)
   (<wd> ^unexpanded-idiom true
         ^wcount <idx>)
-->
   (<s> ^operator <o> +)
   (<o> ^name expand-idiom
        ^priority 1000
        ^order <idx>)
}

sp {global*apply*expand-idiom
   (state <s> ^problem-space lgsoar
              ^operator <o>
              ^io.lgsentence <sent>)
   (<sent> ^links.link <ln>
            ^words.word <wdl>
            ^words.word <wdr>)
   (<o> ^name expand-idiom
        ^order <idx>)
   (<ln> ^ltype ID
         ^lwleft <leftc>
         ^lwright <idx>)
   (<wdl> ^wcount <leftc>
          ^wvalue <lval>)
   (<wdr> ^wcount <idx>
          ^wvalue <rval>
          ^unexpanded-idiom true)
-->
   (<wdr> ^unexpanded-idiom true -
          ^wvalue <rval> -
          ^wvalue (concat <lval> |-| <rval>))
}
