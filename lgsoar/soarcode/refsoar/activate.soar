# File: Activate.soar
# Author: William Taysom
# Version 2.0: July 24, 2001
# Created: July 6, 2001
#
# Desc: Builds tree/ref/model structures from link grammer parses.
#
#   LGparse	--interpret-> refs --realize-> model
#
# Preference: clauses (300 - 251) > anaphor (250-201) > interpret (200 - 100)
#			  > promote (100 - 50 ) > realize (50 - 1)
# Operator Types: (op priorities are in parentheses)
#	global: start-next-sentence (0), processing-complete (0), find-root (170),
#			return to nil
#	interpret: give-root-ref (160), add-arg (150, 220)
#	realize: new-idea (20), coref (30)
#	promote: basic (70-60), feature (70)
#	anaphor: resolve (201, 51), unblock-center (210), unblocking-finished (209),
#			 add-center (203, 201), merge (201), rip (204), cascade (203, 202),
#			 add-elliptical-verb-syntax (205), expand-contraction (205)
#			 remove-non-elliptically-included-semantics (210, 205),
#			 clean-up-merge (200), remove-center (150)
#	clause:	 recognize-introductory-phrase (230), recognize-main-verb (230),
#			 recognize-introductory-verb (235, 230), hide-main-verb (230),
#			 handle-that-clause (10)
#
# Bugs/Issues/'special' features:
# P only interpreted as passive
# MV only interpreted as prepositional
# Fails to realize sentences with empty subjects i.e. "Go to the store."
# All adverbs are interpreted as modes.
# clause.soar is a fix for a problem that the productions in death.xxxxsoar created,
#		namely automatic system failure.  The cause of the problem is suspected to relate
#		to exponential matching in those productions.  clause.soar solves the problem by
#		implementing the guilty productions with several operators.  Also, clause.soar
#		contains other clause related productions.
# Neuter nouns are marked as such in the test case.
#
# TO DO:
#


# need a simple workaround so the sentence can be edited in place
# (it is made of read-only input WMEs)
# Java code changed to make original-wvalue rather than wvalue
sp {activate*elaborate*wvalue
   (state <s> ^io.input-link.lg.parsed-sentence.words.word <wd>)
   (<wd> ^original-wvalue <wv>)
-->
   (<wd> ^wvalue <wv>)
}

# Initialize problem space

sp {top-state*lg*init*sentence
  (state <s> ^superstate nil
             ^io <io>
             ^io.input-link.lg.sentence <sent>)
   (<sent> -^processed)
-->
  (<io> ^lgsentence <sent>)
}


sp	{Activate*create*space
   (state <s> ^io.lgsentence.count <ct> # match only for the minimal count sentence
             -^io.lgsentence.count < <ct>) 
-->
   (<s> ^problem-space lgsoar ^refsets <refsets> ^model <m> ^count <ct> ^root 0 ^anaphor <a>
        ^clauses <clauses> ^next-unidentified-individual 1 ^final-predicates <fp>)
   (<refsets> ^refs <refs> +)
   (<refs> ^count <ct>)
   (<a> ^acount 1 ^centers <centers> ^unblock? no ^merge <merge> ^cascades <cascs>)
   (<cascs> ^records <records> ^ante-off-set nil ^ana-off-set nil)
   (<merge> ^temp nil ^replace nil)
   (<centers> ^center <null-center> +)
   (<null-center> ^ccount 0 ^ref nil ^blocked? no
                  ^kind first +, second +, third +, verb +)
}


