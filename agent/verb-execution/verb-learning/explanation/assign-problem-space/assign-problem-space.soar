### assign a problem space to the current operator being explained based on the information stored in semantic memory. note that only composite operators are stored under problem-space of a operator. primitve actions are proposed by default.


## elaborate assign-problem-space
sp {assign-problem-space*elaborate*state
   (state <s> ^name assign-problem-space
   	      ^superstate.operator <sop>
	      ^smem.command <scomm>)
   (<sop> ^name assign-problem-space
   	  ^problem-space-id <pid>
	  ^map-id <map>)
-->
   (<s> ^problem-space-id <pid>
   	^bit flip
	^map-id <map>)
   (<scomm> ^retrieve <pid>)
   (force-learn <s>) ## to learn proposal rule chunks
}
	  

### if there are operator templates in problem-space-id, generate operators based on them

sp {generate*composite-operator*problem-space*operator*template
   (state <s> ##^name assign-problem-space  SM: not needed because of certain perks 
   	      ^superstate <ss>
	      -^completed <pop>
	      -^name assign-goal)
   (<ss> ^superstate.operator._metadata.map-id <map>)
   (<map> ^problem-space <pid>)
   (<pid> ^operator <pop>)
-->
   (<s> ^operator <op> +)
   (<op> ^name generate-problem-space-operator
   	 ^problem-space-operator-id <pop>
	 ^proposal-state <ss>)
}



### if state-no-change, write desired to the superstate; occurs only if there are any composite operators in the problem-space
sp {assign-problem-space*write*superstate*desired
   (state <s> ^impasse no-change
   	      ^attribute state
	      ^superstate <ss>)
   (<ss> ^name assign-problem-space
   	 ^superstate <sss>)
-->
   (<sss> ^generated yes)
}


## if there are no operators in the problem-space, 
sp {generate*composite-operator*problem-space*operator*none
   (state <s> ^name assign-problem-space
   	      ^problem-space-id <pid>
	      ^superstate <ss>
	      ^smem.result.success <any>)
   (<pid> -^operator <pop>)
-->
   (<ss> ^generated none)
}
   	   
 


